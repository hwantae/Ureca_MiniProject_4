<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ë£¸ ì˜ˆì•½</title>
  <style>
    body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; background: #f5f5f5; }
    h1 { color: #333; }
    .header { margin-bottom: 20px; }
    .slots { display: flex; flex-wrap: wrap; gap: 10px; margin: 20px 0; }
    .slot { padding: 15px 18px; border: 1px solid #ddd; background: #fff; cursor: pointer; text-align: center; min-width: 120px; }
    .slot:hover { background: #e0e0e0; }
    .slot.available { border-color: green; }
    .slot.unavailable { border-color: red; background: #fee; cursor: not-allowed; opacity: 0.85; }
    .slot.reserved { border-color: #666; background: #eee; cursor: not-allowed; opacity: 0.9; }
    .slot.selected { background: #d0e0ff; border-color: blue; }
    .reserve-section { margin-top: 20px; padding: 15px; background: #fff; border: 1px solid #ddd; display: flex; align-items: center; gap: 20px; }
    button { padding: 10px 30px; font-size: 1em; cursor: pointer; }
    button:disabled { background: #ccc; cursor: not-allowed; }
    .meta { color: #666; font-size: 0.95em; margin-top: 10px; }
  </style>
</head>
<body>
  <div class="header"><a href="rooms.html">â† ëª©ë¡ìœ¼ë¡œ</a></div>
  <h1 id="title">ë£¸ ì˜ˆì•½</h1>

  <div style="margin:20px 0;">
    ğŸ“… ë‚ ì§œ: <input type="date" id="date">
  </div>

  <div class="meta">
    ìµœëŒ€ ì´ìš© ì‹œê°„: <span id="maxUsageText">-</span>
  </div>

  <div id="slots" class="slots">ë¡œë”© ì¤‘...</div>

  <div class="reserve-section">
    ì„ íƒ: <span id="selected">ì—†ìŒ</span>
    <button id="reserveBtn" disabled>ì˜ˆì•½í•˜ê¸°</button>
  </div>

<script>
  function getToken() { return sessionStorage.getItem('authToken'); }

  function requireLogin() {
    const token = getToken();
    if (!token) {
      alert("ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.");
      location.href = "/login";
      return false;
    }
    return true;
  }

  const roomName = new URLSearchParams(location.search).get('name') || '';
  if (!roomName) location.href = 'rooms.html';
  document.getElementById('title').textContent = `${roomName} ì˜ˆì•½`;

  const dateInput = document.getElementById('date');
  dateInput.value = new Date().toISOString().split('T')[0];
  dateInput.addEventListener('change', () => loadSlots(dateInput.value));

  let currentMaxUsageMinutes = 120;
  let currentRoomId = null;

  // ìŠ¬ë¡¯ ëª©ë¡(ì‹œê°„ìˆœ) ë³´ê´€
  let slotList = []; // [{slotId, startHHmm, endHHmm, state}]
  // ì—°ì† ì„ íƒ
  let selectedStartIdx = null;
  let selectedEndIdx = null;

  // í‘œì‹œìš©
  function formatHHmm(t) { return (t || "").substring(0, 5); }

  function toLocalDateTimeStr(dateStr, timeStrHHmm) {
    return `${dateStr}T${timeStrHHmm}:00`;
  }

  function minutesOf(hhmm) {
    const [h, m] = hhmm.split(':').map(Number);
    return h * 60 + m;
  }

  function calcRangeMinutes(startIdx, endIdx) {
    const start = slotList[startIdx].startHHmm;
    const end = slotList[endIdx].endHHmm;
    return minutesOf(end) - minutesOf(start);
  }

  async function loadRoomMeta() {
    const res = await fetch('/api/rooms', { headers: { 'X-AUTH-TOKEN': getToken() } });
    const rooms = await res.json();
    const thisRoom = rooms.find(r => r.name === roomName);
    if (!thisRoom) throw new Error("Room not found");
    currentRoomId = thisRoom.roomId;
    currentMaxUsageMinutes = thisRoom.maxUsageMinutes;
    document.getElementById('maxUsageText').textContent = `${currentMaxUsageMinutes}ë¶„`;
  }

  // âœ… ì „ì²´ ì˜ˆì•½(ë‹¤ë¥¸ ì‚¬ëŒ í¬í•¨)ëœ slotId ì¡°íšŒ(í™•ì • ìƒíƒœë§Œ)
  async function loadReservedSlotIds(dateStr) {
    const res = await fetch(`/api/reservations/rooms/${currentRoomId}/reserved-slot-ids?date=${dateStr}`, {
      headers: { 'X-AUTH-TOKEN': getToken() }
    });
    if (!res.ok) return new Set();
    const list = await res.json(); // List<Long>
    return new Set(list || []);
  }

  async function loadBlocks(dateStr) {
    const res = await fetch(`/api/rooms/${currentRoomId}/blocks?date=${dateStr}`, {
      headers: { 'X-AUTH-TOKEN': getToken() }
    });
    if (!res.ok) return new Set();
    const blocks = await res.json();
    return new Set((blocks || []).map(b => formatHHmm(b.startTime)));
  }

  async function loadSlots(dateStr) {
    if (!requireLogin()) return;

    const container = document.getElementById('slots');
    container.innerHTML = "ë¡œë”© ì¤‘...";

    selectedStartIdx = null;
    selectedEndIdx = null;
    updateUI();

    try {
      // 1) roomId, maxUsage
      await loadRoomMeta();

      // 2) TimeSlot ëª©ë¡
      const slotsRes = await fetch(`/api/rooms/name/${encodeURIComponent(roomName)}/slots`, {
        headers: { 'X-AUTH-TOKEN': getToken() }
      });
      const slots = await slotsRes.json();
      if (!slots || slots.length === 0) {
        container.innerHTML = 'ìš´ì˜ ì‹œê°„ ë¯¸ì„¤ì •';
        return;
      }

      // 3) block / reserved
      const blockedStartTimes = await loadBlocks(dateStr);
      const reservedSlotIds = await loadReservedSlotIds(dateStr);

      // 4) slotList êµ¬ì„± (ì •ë ¬ë¼ì„œ ì˜¨ë‹¤ëŠ” ì „ì œ: repository orderByStartTimeAsc)
      slotList = slots.map(s => {
        const start = formatHHmm(s.startTime);
        const end = formatHHmm(s.endTime);
        const isBlocked = blockedStartTimes.has(start);
        const isReserved = reservedSlotIds.has(s.slotId);

        let state = 'available';
        if (isBlocked) state = 'unavailable';
        else if (isReserved) state = 'reserved';

        return { slotId: s.slotId, startHHmm: start, endHHmm: end, state };
      });

      // 5) ë Œë”ë§
      let html = '';
      slotList.forEach((s, idx) => {
        const cls = s.state;
        const clickable = (cls === 'available') ? `onclick="handleSlotClick(${idx})"` : '';
        html += `<div id="slot-${idx}" class="slot ${cls}" ${clickable}>
                  ${s.startHHmm} ~ ${s.endHHmm}
                </div>`;
      });
      container.innerHTML = html;

    } catch (e) {
      console.error(e);
      container.innerHTML = 'ë¡œë“œ ì‹¤íŒ¨';
    }
  }

  // ì—°ì† ì„ íƒ ë¡œì§ ë³µêµ¬:
  // 1) ì²« í´ë¦­: start
  // 2) ë‘ë²ˆì§¸ í´ë¦­: end (start~end ë²”ìœ„)
  // 3) ì„¸ë²ˆì§¸ í´ë¦­: start ì¬ì„¤ì •
  function handleSlotClick(idx) {
    if (slotList[idx].state !== 'available') return;

    if (selectedStartIdx === null) {
      selectedStartIdx = idx;
      selectedEndIdx = null;
      renderSelection();
      return;
    }

    if (selectedEndIdx === null) {
      // end ì„ íƒ ë‹¨ê³„
      let start = selectedStartIdx;
      let end = idx;

      if (end < start) { // ì—­ì„ íƒì´ë©´ swap
        [start, end] = [end, start];
      }

      // ì¤‘ê°„ì— unavailable/reserved ë¼ë©´ ë§‰ê¸°
      for (let i = start; i <= end; i++) {
        if (slotList[i].state !== 'available') {
          alert('ì„ íƒí•œ êµ¬ê°„ì— ì˜ˆì•½ ë¶ˆê°€ëŠ¥í•œ ì‹œê°„ì´ í¬í•¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤.');
          return;
        }
      }

      // ìµœëŒ€ ì´ìš© ì‹œê°„ ì²´í¬
      const minutes = calcRangeMinutes(start, end);
      if (minutes > currentMaxUsageMinutes) {
        alert(`ìµœëŒ€ ì´ìš© ì‹œê°„ì€ ${currentMaxUsageMinutes}ë¶„ì…ë‹ˆë‹¤.`);
        return;
      }

      selectedStartIdx = start;
      selectedEndIdx = end;
      renderSelection();
      return;
    }

    // ì´ë¯¸ ë²”ìœ„ ì„ íƒë˜ì–´ ìˆìœ¼ë©´ ìƒˆ ì‹œì‘ìœ¼ë¡œ ë¦¬ì…‹
    selectedStartIdx = idx;
    selectedEndIdx = null;
    renderSelection();
  }

  function renderSelection() {
    document.querySelectorAll('.slot').forEach(e => e.classList.remove('selected'));

    if (selectedStartIdx !== null && selectedEndIdx === null) {
      const el = document.getElementById(`slot-${selectedStartIdx}`);
      if (el) el.classList.add('selected');
    } else if (selectedStartIdx !== null && selectedEndIdx !== null) {
      for (let i = selectedStartIdx; i <= selectedEndIdx; i++) {
        const el = document.getElementById(`slot-${i}`);
        if (el) el.classList.add('selected');
      }
    }
    updateUI();
  }

  function updateUI() {
    const btn = document.getElementById('reserveBtn');
    const span = document.getElementById('selected');

    if (selectedStartIdx === null) {
      span.textContent = 'ì—†ìŒ';
      btn.disabled = true;
      return;
    }

    if (selectedEndIdx === null) {
      const s = slotList[selectedStartIdx];
      span.textContent = `${s.startHHmm} ~ ${s.endHHmm}`;
      btn.disabled = false;
      return;
    }

    const s = slotList[selectedStartIdx];
    const e = slotList[selectedEndIdx];
    const minutes = calcRangeMinutes(selectedStartIdx, selectedEndIdx);
    span.textContent = `${s.startHHmm} ~ ${e.endHHmm} (${minutes}ë¶„)`;
    btn.disabled = false;
  }

  // âœ… ì˜ˆì•½ API í˜¸ì¶œ: ì„ íƒ ë²”ìœ„ ë‚´ ìŠ¬ë¡¯ë“¤ì„ ìˆœì„œëŒ€ë¡œ ì˜ˆì•½ ìƒì„±
  document.getElementById('reserveBtn').onclick = async () => {
    if (!requireLogin()) return;
    if (selectedStartIdx === null) return;

    const dateStr = dateInput.value;

    let start = selectedStartIdx;
    let end = (selectedEndIdx === null) ? selectedStartIdx : selectedEndIdx;

    // ìµœì¢… ë°©ì–´(ë‹¤ì‹œ í•œ ë²ˆ maxUsage)
    const minutes = calcRangeMinutes(start, end);
    if (minutes > currentMaxUsageMinutes) {
      alert(`ìµœëŒ€ ì´ìš© ì‹œê°„ì€ ${currentMaxUsageMinutes}ë¶„ì…ë‹ˆë‹¤.`);
      return;
    }

    const targets = slotList.slice(start, end + 1);

    try {
      for (const s of targets) {
        const payload = {
          roomId: currentRoomId,
          slotId: s.slotId,
          startTime: toLocalDateTimeStr(dateStr, s.startHHmm),
          endTime: toLocalDateTimeStr(dateStr, s.endHHmm)
        };

        const res = await fetch('/api/reservations', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-AUTH-TOKEN': getToken()
          },
          body: JSON.stringify(payload)
        });

        if (!res.ok) {
          const msg = await res.text();
          alert(`ì˜ˆì•½ ì‹¤íŒ¨(${s.startHHmm}): ${msg}`);
          return;
        }
      }

      alert("ì˜ˆì•½ ì™„ë£Œ!");
      await loadSlots(dateStr);

    } catch (e) {
      console.error(e);
      alert("ì„œë²„ í†µì‹  ì˜¤ë¥˜");
    }
  };

  loadSlots(dateInput.value);
</script>
</body>
</html>
